# Plotting functions for shiny and regular visualizations.

# plot tree
plot_tree <- function(tree, save) {
  if (save) {
    setEPS()
    postscript(file = paste0(deparse(substitute(tree)), ".eps"))
    rattle::fancyRpartPlot(tree, type = 5, sub = "")
    dev.off()
  }
  else {
    rattle::fancyRpartPlot(tree, type = 5, sub = deparse(substitute(tree)))
  }
}

plot_pca <- function(.data) {
  pca  <- prcomp(FSMJ_dist %>% dplyr::select("Distance", .$inputs))
  fit <- fastcluster::hclust(dist(pca$x[, 1:3]))
  groups <- cutree(fit, k = 4)

  plotly::plot_ly() %>%
    plotly::add_trace(
      x = pca$x[, 1],
      y = pca$x[, 2],
      z = pca$x[, 3],
      color = groups,
      size = 4,
      opacity = 0.7,
      type = "scatter3d",
      mode = "markers") %>%
    plotly::toWebGL()
}

plot_pca_princomp <- function(.data) {
  scores <- .data$scores
  x <- scores[, 1]
  y <- scores[, 2]
  z <- scores[, 3]

  loads <- .data$loadings

  scale.loads <- 5

  p <- plotly::plot_ly() %>%
    plotly::add_trace(x = x, y = y, z = z,
                      type = "scatter3d",
                      mode = "markers",
                      marker = list(color = y,
                                    colorscale = c("#FFE1A1", "#683531"),
                                    opacity = 0.7))
  for (k in seq_len(nrow(loads))) {
    x <- c(0, loads[k, 1]) * scale.loads
    y <- c(0, loads[k, 2]) * scale.loads
    z <- c(0, loads[k, 3]) * scale.loads
    p <- p %>% plotly::add_trace(x = x, y = y, z = z,
                                 type = "scatter3d", mode = "lines",
                                 line = list(width = 8),
                                 opacity = 1)
  }
  print(p %>% plotly::toWebGL())
}

plot_splom <- function(.data) {
  .data %>%
    plotly::plot_ly(type = "splom", dimensions = list(
      list(label = "maxOut", values = ~maxOut),
      list(label = "minLT_Plant", values = ~minLT_Plant),
      list(label = "minLeanBuffer", values = ~minLeanBuffer),
      list(label = "minWaitingParts", values = ~minWaitingParts)
    ),
    #text=~Cluster,
    color = ~Cluster,
    marker = list(
      #color = as.integer(.data$Cluster),
      #colorscale = ,
      size = 7
    ),
    showupperhalf = FALSE,
    diagonal = list(visible = FALSE))
}

#' @export
plot2d <- function(.data, x, y, color = "Rank", unselected_data = NULL, pareto = TRUE, ...) {
  p <- plotly::plot_ly(type = "scattergl",
                       name = "All Data",
                       x = stats::as.formula(paste0("~", x)),
                       y = stats::as.formula(paste0("~", y)),
                       color = stats::formula(paste0("~", color)),
                       customdata = ~Iteration,
                       data = .data,
                       mode = "markers",
                       size = I(30),
                       opacity = 1,
                       hovertemplate = paste(paste0("<b>", x, "</b>: %{x}"),
                                             paste0("<br><b>", y, "</b>: %{y}"),
                                             paste0("<br><b>Iteration</b>: %{customdata}<extra></extra>")),
                  ...)
  if (!is.null(unselected_data)) {
    p <- p %>% addunselected(unselected_data)
  }

  if (pareto) {
    p <- p %>% plotly::add_markers(data = .data$pareto,
                                   name = "Pareto",
                                   opacity = 1)
  }
  p
}

#' @export
plot3d <- function(.data, x, y, z, color = "Rank", unselected_data = NULL, pareto = TRUE, ...) {
  suppressWarnings(
    p <- plotly::plot_ly(type = "scatter3d",
                         name = "All Data",
                         x = stats::as.formula(paste0("~", x)),
                         y = stats::as.formula(paste0("~", y)),
                         z = stats::as.formula(paste0("~", z)),
                         color = stats::formula(paste0("~", color)),
                         customdata = ~Iteration,
                         hovertemplate = paste(paste0("<b>", x, "</b>: %{x}"),
                                               paste0("<br><b>", y, "</b>: %{y}"),
                                               paste0("<br><b>", z, "</b>: %{z}"),
                                               paste0("<br><b>Iteration</b>: %{customdata}<extra></extra>")),
                         mode = "markers",
                         size = I(30),
                         opacity = 1,
                         data = .data,
                         ...))

  if (!is.null(unselected_data)) {
    p <- p %>% addunselected(unselected_data)
  }

  if (pareto) {
    p <- p %>% plotly::add_markers(data = .data$pareto,
                                   name = "Pareto",
                                   opacity = 1)
  }
  p
}

#' Plot multi-objective optimization data
#'
#' Plot data in either two or three dimensions using plotly.
#'
#' @param .data The dataset generated by [load_dataset()].
#'
#' @param pareto Should the pareto front be displayed as a separate entry?
#'
#' @param ... Additional parameters to the function. Possible to define x, y, z, and color parameters.
#' If the dimensions are not set, they are read from .data.
#' Non-matched arguments will be further piped to [plotly::plot_ly()].
#'
#' @author Simon Lidberg
#'
#' @examples
#' # Plot in three dimensions with "Rank" as color parameter and
#' # default axis read from .data$objective_names.
#' plotnd(SCORER::FMC)
#'
#' # All objectives defined, along with color parameter.
#' plotnd(SCORER::FMC, x = "TP", y = "Investment", z = "LeanBuffer", color = "Iteration")
#'
#' @export
plotnd <- function(.data, pareto = TRUE, ...) {
  stopifnot("You need more than one objective to plot" = length(.data$objective_names) > 1) # Requires two objectives as minimum.
  #arguments <- match.call(expand.dots = TRUE)
  arguments <- list(...)

  objectives <- .data$objective_names
  plotting_objectives <- list(x = NULL, y = NULL, z = NULL, color = "Rank")

  # Check for supplied arguments
  for (argname in c("x", "y", "z", "color")) {
    # If the argument is supplied or the argument is missing in the dataset
    if (!is.null(arguments[[argname]]) ||
        (!is.null(arguments[[argname]]) && !(arguments[[argname]] %in% colnames(.data)))) {
      if (arguments[[argname]] %in% colnames(.data)) {
        # The column exists in the dataset, assign it as a plotting objective.
        plotting_objectives[argname] <- arguments[[argname]]
        # Update the objective vector with the new objectives
        objectives <- objectives[!(objectives %in% arguments[[argname]])]
      }
      # Remove it from the arguments list, treat it as handled.
      # arguments is further passed to the next function.
      arguments[argname] <- NULL
    }
  }

  # Set correct defaults.
  for (argname in c("x", "y", "z", "color")) {
    if (is.null(plotting_objectives[[argname]])) {
      plotting_objectives[[argname]] <- objectives[1]
      objectives <- objectives[!(objectives %in% plotting_objectives[[argname]])]
    }
  }

  # Determine the number of user assigned elements.
  dimensions_to_plot <- sum(names(plotting_objectives) %in% c("x", "y", "z")) -
    sum(is.na(plotting_objectives[c("x", "y", "z")]))

  if (dimensions_to_plot == 2 || (dimensions_to_plot < 2 && length(objectives) == 2)) {
    p <- do.call(plot2d, append(arguments, list(.data = .data,
                   x = plotting_objectives[["x"]],
                   y = plotting_objectives[["y"]],
                   color = plotting_objectives[["color"]],
                   pareto = pareto)))
  } else {
    p <- do.call(plot3d, append(arguments, list(.data = .data,
                   x = plotting_objectives[["x"]],
                   y = plotting_objectives[["y"]],
                   z = plotting_objectives[["z"]],
                   color = plotting_objectives[["color"]],
                   pareto = pareto)))
  }

  p
}

addunselected <- function(.plot, unselected_data) {
  .plot %>% plotly::add_trace(
    color = I("gray"),
    size = I(10),
    opacity = 0.2,
    data = unselected_data,
    showlegend = FALSE) %>%
    plotly::layout(updatemenus = list(
      list(
        type = "buttons",
        x = 1,
        buttons = list(
          list(method = "restyle",
               args = list("visible", c(TRUE, TRUE)),
               args2 = list("visible", c(TRUE, FALSE)),
               label = "Toggle filtered")
          )
        )
      )
    )
}

add_dropdowns <- function(.plot, objectives) {
  axis <- c("x", "y", "z", "color")
  augmented_obj <- c(objectives, "Rank")
  list(create_dropdown(1, "x", augmented_obj),
       create_dropdown(2, "y", augmented_obj),
       create_dropdown(3, "z", augmented_obj),
       create_dropdown(4, "color", augmented_obj))
}

create_dropdown <- function(i, axis, obj) {
  list(
    type = "list",
    x = 1,
    xanchor = "left",
    yanchor = "top",
    y = 0.1*i,
    active = i-1,
    buttons = create_buttons(axis, obj)
  )
}

create_buttons <- function(axis, objectives) {
  buttons <- list()
  for (i in seq_along(objectives)) {
    obj <- objectives[i]
    buttons[[i]] <- list(
      method = "update",
      args = list(list(x = list(ACM[[obj]])),
                  list(scene = list(xaxis = list(title = list(text = obj))))),
      label = obj
    )
  }
  buttons
}
